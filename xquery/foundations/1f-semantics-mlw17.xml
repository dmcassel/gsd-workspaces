<export><workspace name="1f-semantics-mlw17"><query name="create-triples-1" focus="false" listorder="1" taborder="2" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="xquery">xquery version "1.0-ml";
import module namespace sem = "http://marklogic.com/semantics"
   at "/MarkLogic/semantics.xqy";
   
(: Creating triples using sem:triples()
 : These triples create the relationship:
 : CustomerID placed OrderID .
:)

let $sem-prefix := "http://www.marklogic.com/orders#"
let $uris := cts:uris('','document',cts:collection-query("order"))
                                                   
for $uri in $uris
let $order := fn:doc($uri)
let $order-id := $order/order/id/fn:string(.)
let $customer-id := $order/order/customer_id/fn:string(.)
let $products := $order/order/order_lines/order_line/product/fn:string(.)

let $triples := (
  sem:triple(sem:iri($sem-prefix || "Customer" || $customer-id),
             sem:iri($sem-prefix || "placed"),
             sem:iri($sem-prefix || "Order" || $order-id))
)


return $triples</query><query name="create-triple-header" focus="false" listorder="2" taborder="4" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="xquery">xquery version "1.0-ml";
import module namespace sem = "http://marklogic.com/semantics"
   at "/MarkLogic/semantics.xqy";
(: Creating triples using sem:triples()
 : These triples create the relationship:
 :      CustomerID placed OrderID .
 :      OrderID contains ProductID .
 : and places them in a &lt;triples&gt; section which we'll
 : later add to our envelopes.
:)

let $sem-prefix := "http://www.marklogic.com/orders#"
let $uris := cts:uris('','document',cts:collection-query("order"))                                                   
for $uri in $uris
let $order := fn:doc($uri)
let $order-id := $order/order/id/fn:string(.)
let $customer-id := $order/order/customer_id/fn:string(.)
let $products := $order/order/order_lines/order_line/product/fn:string(.)

let $triples := (
  sem:triple(sem:iri($sem-prefix || "Customer" || $customer-id),
             sem:iri($sem-prefix || "placed"),
             sem:iri($sem-prefix || "Order" || $order-id)),
   for $prod in $products
   return sem:triple(sem:iri($sem-prefix || "Order" || $order-id),
                     sem:iri($sem-prefix || "contains"),
                     sem:iri($sem-prefix || "Product" || $prod))
)

let $triple-header := &lt;triples&gt;
                       {$triples}
                      &lt;/triples&gt;
return $triple-header</query><query name="create-triples-2" focus="false" listorder="3" taborder="3" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="xquery">xquery version "1.0-ml";
import module namespace sem = "http://marklogic.com/semantics"
   at "/MarkLogic/semantics.xqy";
(: Creating triples using sem:triples()
 : These triples create the relationship:
 :      CustomerID placed OrderID .
 :      OrderID contains ProductID .
:)
let $sem-prefix := "http://www.marklogic.com/orders#"
let $uris := cts:uris('','document',cts:collection-query("order"))                                                   
for $uri in $uris
let $order := fn:doc($uri)
let $order-id := $order/order/id/fn:string(.)
let $customer-id := $order/order/customer_id/fn:string(.)
let $products := $order/order/order_lines/order_line/product/fn:string(.)

let $triples := (
  sem:triple(sem:iri($sem-prefix || "Customer" || $customer-id),
             sem:iri($sem-prefix || "placed"),
             sem:iri($sem-prefix || "Order" || $order-id)),
   for $prod in $products
   return sem:triple(sem:iri($sem-prefix || "Order" || $order-id),
                     sem:iri($sem-prefix || "contains"),
                     sem:iri($sem-prefix || "Product" || $prod))
)


return $triples</query><query name="add-triples" focus="false" listorder="4" taborder="5" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="xquery">xquery version "1.0-ml";
import module namespace sem = "http://marklogic.com/semantics"
   at "/MarkLogic/semantics.xqy";
(: This script creates the triples and places them in a
 : &lt;triples&gt; section within our Order entity envelopes.
:)

let $sem-prefix := "http://www.marklogic.com/orders#"
let $uris := cts:uris('','document',cts:collection-query("order"))                                                   
for $uri in $uris
  let $order := fn:doc($uri)
  let $order-id := $order/order/id/fn:string(.)
  let $customer-id := $order/order/customer_id/fn:string(.)
  let $products := $order/order/order_lines/order_line/product/fn:string(.)

  let $triples := (
    sem:triple(sem:iri($sem-prefix || "Customer" || $customer-id),
               sem:iri($sem-prefix || "placed"),
               sem:iri($sem-prefix || "Order" || $order-id)),
    for $prod in $products
    return sem:triple(sem:iri($sem-prefix || "Order" || $order-id),
                      sem:iri($sem-prefix || "contains"),
                      sem:iri($sem-prefix || "Product" || $prod)) 
  )

  let $triple-header := &lt;triples&gt;
                         {$triples}
                        &lt;/triples&gt;
  let $harmonized :=
      &lt;order&gt;
         {$triple-header} 
         &lt;source&gt;
           {$order/order/*}
         &lt;/source&gt;
      &lt;/order&gt;
  
return  xdmp:document-insert($uri, $harmonized, (), ("order","enveloped")) </query><query name="Products By Key 2" focus="false" listorder="5" taborder="5" active="false" database="8469375127942903998" server="6240101570028256752" database-name="" server-name="" mode="xquery">xquery version "1.0-ml";
(: have to update once we modify envelope :)

let $customer-doc := fn:doc("/denormalized/customer-3.xml")
let $customer-id := $customer-doc/customer/source/customer_id

let $orders := fn:collection("order")/order/source[customer_id eq $customer-id]
let $prod-ids := fn:distinct-values($orders/order_lines/order_line/product/text())

let $products := fn:collection("product")/product[id eq $prod-ids]
return  $products/(&lt;prod&gt;{name, sku}&lt;/prod&gt;) 
</query><query name="SPARQL-SELECT" focus="false" listorder="6" taborder="6" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="sparql"># query
# Show me the Customers who placed an Order 
# containing Product5

PREFIX : &lt;http://www.marklogic.com/orders#&gt;  

SELECT ?customer
WHERE {
	?customer :placed ?order .
	?order :contains :Product5 }
</query><query name="SPARQL-CONSTRUCT" focus="false" listorder="7" taborder="7" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="sparql"># Creating a new fact/relationshipos
# Create a relationship that defines when a Customer places an Order
# that contains a Product, we can state the Customer "bought"
# the Product

PREFIX : &lt;http://www.marklogic.com/orders#&gt;  

CONSTRUCT { ?customer :bought ?product }
WHERE {
	?customer :placed ?order .
	?order :contains ?product }

</query><query name="SPARQL-INSERT" focus="false" listorder="8" taborder="8" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="sparql-update"># SPARQL UPDATE
# Insert our new triples into the database

PREFIX : &lt;http://www.marklogic.com/orders#&gt;  

INSERT 
{ GRAPH &lt;order-details&gt; { ?customer :bought ?product }  }
  WHERE {
	  ?customer :placed ?order .
	  ?order :contains ?product 
}
</query><query name="SPARQL-bought" focus="false" listorder="9" taborder="9" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="sparql"># query
# Show me customers who have bought Product5

PREFIX : &lt;http://www.marklogic.com/orders#&gt;  

SELECT ?customer
WHERE { ?customer :bought :Product5 } </query><query name="Add Comments" focus="false" listorder="10" taborder="10" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="sparql-update">## SPARQL UPDATE
# add comments to the database to define the meaning of what 
# our predicates/relatioships mean

PREFIX : &lt;http://www.marklogic.com/orders#&gt;  

INSERT DATA {
  GRAPH &lt;order-comments&gt; {
    :placed :comment 'Used to describe when a customer made the order. Use Fulfilled for when it was shipped. Use Closed after it was billed.' .
    :bought :comment 'CONSTRUCT { ?customer :bought ?product } WHERE {  ?customer :placed ?order . ?order :contains ?product . }' .

  }
}
 
</query><query name="Query Comment" focus="false" listorder="11" taborder="11" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="sparql">#query our comment for the 'placed' predicate
PREFIX : &lt;http://www.marklogic.com/orders#&gt;  

SELECT $comment
WHERE{
    :placed :comment $comment
     }
 </query><query name="Add Labels" focus="false" listorder="12" taborder="12" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="xquery">xquery version "1.0-ml";
import module namespace sem = "http://marklogic.com/semantics"
   at "/MarkLogic/semantics.xqy";
(: Add additional labels for our Products and Customers so we can 
 : query using the labels
:)

let $sem-prefix := "http://www.marklogic.com/orders#"
let $order-uris := cts:uris('','document',cts:collection-query("order"))                                                   
let $prod-ids := for $uri in $order-uris
                 let $order := fn:doc($uri)
                 let $id :=  $order/order/source/order_lines/order_line/product/fn:string(.) 
                 return $id         
                 
let $prod-triples := 
   for $prod-id in fn:distinct-values($prod-ids)
   let $prod-name := /product[id eq $prod-id]/name/fn:string(.)
   let $triple:=    sem:triple(sem:iri($sem-prefix || "Product" || $prod-id),
                               sem:iri($sem-prefix || "label"),
                               $prod-name)
   return $triple
  
let $cust-ids := /customer/source/customer_id/fn:string(.) (: some standardization of ids required :)
let $cust-triples :=
   for $cust-id in $cust-ids
   let $last-name := /customer/source[customer_id eq $cust-id]/last_name/fn:string(.)
   let $triple:=    sem:triple(sem:iri($sem-prefix || "Customer" || $cust-id),
                               sem:iri($sem-prefix || "label"),
                               $last-name)
   return $triple

return sem:rdf-insert(( $cust-triples, $prod-triples ),(),(), "order-details")
  </query><query name="fn:doc()" focus="false" listorder="13" taborder="13" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="xquery">xquery version "1.0-ml";
(: query the triplestore document.xml created in the previous tab, "Add Labels" :)
fn:doc("/triplestore/1cd9d77bdb581361.xml")</query><query name="SPARQL-labels" focus="false" listorder="14" taborder="14" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="sparql">#Show me the product name for Product5
PREFIX : &lt;http://www.marklogic.com/orders#&gt;  

SELECT   ?productname
WHERE {
	:Product5 :label ?productname .
  }</query><query name="SPARQL-labels-2" focus="true" listorder="15" taborder="15" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="sparql">#Show me the name of the customers which purchased the product "Domainer"
PREFIX : &lt;http://www.marklogic.com/orders#&gt;  

SELECT   ?lname
WHERE {
  ?customer :label $lname .
	?customer :placed ?order .
	?order :contains ?product .
  $product :label "Domainer". }</query><query name="Intro" focus="false" listorder="16" taborder="1" active="true" database="8469375127942903998" server="12590722383439523806" database-name="Documents" server-name="App-Services" mode="xquery">"
This workspace illustrates Semantics by demonstrating how we can
create and query triples using thesem:* API.

We envelope our Order entities and add a triples header to the envelope
which contains the relationships:

CustomerID placed OrderID.
OrderID contains ProductID.

We additionally add comments to our relationships and labels for our Customers and Products.

"</query></workspace></export>
