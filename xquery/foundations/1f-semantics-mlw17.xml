<export><workspace name="1f-semantics-mlw17"><query name="orders-by-key" focus="false" active="true" content-source="as:6240101570028256752:" mode="xquery">xquery version "1.0-ml";
(:
Query Related Orders, Products by Key
Add Triples to Envelope
Query Related Orders by Triple
Addional Metadata to relationships
:)
let $customer-doc := fn:doc("/denormalized/customer-3.xml")
let $customer-id := $customer-doc/customer/source/customer_id
let $orders := fn:collection("order")/order[customer_id eq $customer-id]
return ($customer-doc, $orders )</query><query name="products-by-key" focus="false" active="true" content-source="as:6240101570028256752:" mode="xquery">xquery version "1.0-ml";
(:won't work after enveloped:)

let $customer-doc := fn:doc("/denormalized/customer-3.xml")
let $customer-id := $customer-doc/customer/source/customer_id

let $orders := fn:collection("order")/order[customer_id eq $customer-id]
let $prod-ids := fn:distinct-values($orders/order_lines/order_line/product/text())

let $products := fn:collection("product")/product[id eq $prod-ids]
return $products/(&lt;prod&gt;{name, sku}&lt;/prod&gt;)
</query><query name="create-triples-1" focus="false" active="true" content-source="as:6240101570028256752:" mode="xquery">xquery version "1.0-ml";

import module namespace sem = "http://marklogic.com/semantics"
   at "/MarkLogic/semantics.xqy";

let $sem-prefix := "http://www.marklogic.com/orders#"
let $uris := cts:uris('','document',cts:collection-query("order"))
                                                   
for $uri in $uris
let $order := fn:doc($uri)
let $order-id := $order/order/id/fn:string(.)
let $customer-id := $order/order/customer_id/fn:string(.)
let $products := $order/order/order_lines/order_line/product/fn:string(.)

let $triples := (
  sem:triple(sem:iri($sem-prefix || "Customer" || $customer-id),
             sem:iri($sem-prefix || "placed"),
             sem:iri($sem-prefix || "Order" || $order-id))
)


return $triples</query><query name="create-triple-header" focus="false" active="true" content-source="as:6240101570028256752:" mode="xquery">xquery version "1.0-ml";

import module namespace sem = "http://marklogic.com/semantics"
   at "/MarkLogic/semantics.xqy";

let $sem-prefix := "http://www.marklogic.com/orders#"
let $uris := cts:uris('','document',cts:collection-query("order"))                                                   
for $uri in $uris
let $order := fn:doc($uri)
let $order-id := $order/order/id/fn:string(.)
let $customer-id := $order/order/customer_id/fn:string(.)
let $products := $order/order/order_lines/order_line/product/fn:string(.)

let $triples := (
  sem:triple(sem:iri($sem-prefix || "Customer" || $customer-id),
             sem:iri($sem-prefix || "placed"),
             sem:iri($sem-prefix || "Order" || $order-id)),
   for $prod in $products
   return sem:triple(sem:iri($sem-prefix || "Order" || $order-id),
                     sem:iri($sem-prefix || "contains"),
                     sem:iri($sem-prefix || "Product" || $prod))
)

let $triple-header := &lt;triples&gt;
                       {$triples}
                      &lt;/triples&gt;
return $triple-header</query><query name="create-triples-2" focus="false" active="true" content-source="as:6240101570028256752:" mode="xquery">xquery version "1.0-ml";

import module namespace sem = "http://marklogic.com/semantics"
   at "/MarkLogic/semantics.xqy";

let $sem-prefix := "http://www.marklogic.com/orders#"
let $uris := cts:uris('','document',cts:collection-query("order"))                                                   
for $uri in $uris
let $order := fn:doc($uri)
let $order-id := $order/order/id/fn:string(.)
let $customer-id := $order/order/customer_id/fn:string(.)
let $products := $order/order/order_lines/order_line/product/fn:string(.)

let $triples := (
  sem:triple(sem:iri($sem-prefix || "Customer" || $customer-id),
             sem:iri($sem-prefix || "placed"),
             sem:iri($sem-prefix || "Order" || $order-id)),
   for $prod in $products
   return sem:triple(sem:iri($sem-prefix || "Order" || $order-id),
                     sem:iri($sem-prefix || "contains"),
                     sem:iri($sem-prefix || "Product" || $prod))
)


return $triples</query><query name="add-triples" focus="false" active="true" content-source="as:6240101570028256752:" mode="xquery">xquery version "1.0-ml";

import module namespace sem = "http://marklogic.com/semantics"
   at "/MarkLogic/semantics.xqy";

let $sem-prefix := "http://www.marklogic.com/orders#"
let $uris := cts:uris('','document',cts:collection-query("order"))                                                   
for $uri in $uris
  let $order := fn:doc($uri)
  let $order-id := $order/order/id/fn:string(.)
  let $customer-id := $order/order/customer_id/fn:string(.)
  let $products := $order/order/order_lines/order_line/product/fn:string(.)

  let $triples := (
    sem:triple(sem:iri($sem-prefix || "Customer" || $customer-id),
               sem:iri($sem-prefix || "placed"),
               sem:iri($sem-prefix || "Order" || $order-id)),
    for $prod in $products
    return sem:triple(sem:iri($sem-prefix || "Order" || $order-id),
                      sem:iri($sem-prefix || "contains"),
                      sem:iri($sem-prefix || "Product" || $prod)) 
  )

  let $triple-header := &lt;triples&gt;
                         {$triples}
                        &lt;/triples&gt;
  let $harmonized :=
      &lt;order&gt;
         {$triple-header} 
         &lt;source&gt;
           {$order/order/*}
         &lt;/source&gt;
      &lt;/order&gt;
  
return  xdmp:document-insert($uri, $harmonized, (), ("order","enveloped")) </query><query name="Products By Key 2" focus="false" active="false" content-source="as:6240101570028256752:" mode="xquery">xquery version "1.0-ml";
(: have to update once we modify envelope :)

let $customer-doc := fn:doc("/denormalized/customer-3.xml")
let $customer-id := $customer-doc/customer/source/customer_id

let $orders := fn:collection("order")/order/source[customer_id eq $customer-id]
let $prod-ids := fn:distinct-values($orders/order_lines/order_line/product/text())

let $products := fn:collection("product")/product[id eq $prod-ids]
return  $products/(&lt;prod&gt;{name, sku}&lt;/prod&gt;) 
</query><query name="SPARQL-1" focus="false" active="true" content-source="as:6240101570028256752:" mode="sparql">## query
PREFIX : &lt;http://www.marklogic.com/orders#&gt;  


SELECT ?customer
WHERE {
	?customer :placed ?order .
	?order :contains :Product5 }
</query><query name="SPARQL-2" focus="false" active="true" content-source="as:6240101570028256752:" mode="sparql">PREFIX : &lt;http://www.marklogic.com/orders#&gt;  

CONSTRUCT { ?customer :bought ?product }
WHERE {
	?customer :placed ?order .
	?order :contains ?product }.

SELECT ?customer
WHERE { ?customer :bought :Product3 }
</query><query name="SPARQL-3" focus="true" active="true" content-source="as:6240101570028256752:" mode="sparql">## query
##Comments and labels for customer and products - create separate triples</query></workspace></export>
