<?xml version="1.0" encoding="UTF-8"?>
<export><workspace name="4-combinations-mlw17"><query active="true" focus="true" mode="xquery" name="0 Intro">"
This workspace explores various use cases and techniques for combining the options you have for
querying documents and data in MarkLogic.

Since there are different kinds of indexes and query languages in MarkLogic, sometimes you will
want to manage various aspects of your data in different modes, and hence the combination of APIs
and query languages may provide simplicity and performance boosts for your use cases.

"</query><query active="true" focus="false" mode="xquery" name="2 SQL + cts">(: This query runs SQL over just the documents that contain the word "ants".
  Since the envelope documents contain the original documents verbatim, even data that has not
  been integrated into the canonical model can be used in search selection.
  :)
xdmp:sql("SELECT * from Product",
   (),
   (),
   cts:word-query("ants"))</query><query active="true" focus="false" mode="xquery" name="4 SPARQL + cts">(: This query runs SPARQL over just the documents that contain the word "ants".
  Since the envelope documents contain the original documents verbatim, even data that has not
  been integrated into the canonical model can be used in search selection.
  :)
sem:sparql("SELECT ?s ?p ?o WHERE { ?s ?p ?o }",
   (),
   (),
   cts:word-query("ants"))</query><query active="true" focus="false" mode="xquery" name="SQL + range query">declare namespace es = "http://marklogic.com/entity-services";

(: This query runs an aggregate in SQL over just the orders with totals above a certain threshold.
  Check the admin GUI to see how the path range index was defined for this model and property.
  Note that since range query matches documents this query returns all orders that have at least
  one item greater than 3000, which is different from the SQL below with a WHERE clause.
  :)
xdmp:sql('SELECT * from "Order_OrderLines"',
   (),
   (),
   cts:range-query(cts:path-reference("//es:instance/Order/orderLines/OrderLine/total"), "&gt;", 3000));
   
xdmp:sql('SELECT * from "Order_OrderLines" WHERE total &gt; 3000')
</query><query active="true" focus="false" mode="xquery" name="5 SPARQL with builtins">(:
  SPARQL can use MarkLogic built-in functions.
:)
sem:sparql('
PREFIX cts: &lt;http://marklogic.com/cts#&gt;
SELECT ?s ?p ?o WHERE { ?s ?p ?o . 
FILTER (cts:contains(?o, "lacus"))}'
)</query><query active="true" focus="false" mode="xquery" name="6 search in SPARQL?!">(:
  SPARQL can use MarkLogic built-in functions.
  this is BAD
:)
sem:sparql('
PREFIX cts: &lt;http://marklogic.com/cts#&gt;
PREFIX fn: &lt;http://www.w3.org/2005/xpath-functions#&gt;

SELECT ?x WHERE { 
BIND (fn:head(cts:search(fn:collection(), "lacus")) as ?x)}'
)</query><query active="true" focus="false" mode="xquery" name="7 documents in sparql">(:
  SPARQL can use MarkLogic built-in functions.
:)
sem:sparql('
PREFIX fn: &lt;http://www.w3.org/2005/xpath-functions#&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX xdmp: &lt;http://marklogic.com/xdmp#&gt;

SELECT ?s ?d
WHERE {
?s rdfs:isDefinedBy ?o
BIND (fn:doc(?o) as ?d)
}
LIMIT 10
'
) ! map:get(., "d")//id</query><query active="true" focus="false" mode="xquery" name="8 SQL values as bindings">xquery version "1.0-ml";

declare namespace es = "http://marklogic.com/entity-services";

let $m := map:map()=&gt;map:with("t", cts:values(cts:path-reference("//es:instance/Order/orderLines/OrderLine/total"), 1000))
return ($m, xdmp:sql("SELECT * from Order_OrderLines where total &gt;= @t", (), $m))
</query><query active="true" focus="false" mode="xquery" name="9 ranges">xquery version "1.0-ml";
declare namespace es = "http://marklogic.com/entity-services";

for $bucket in cts:value-ranges(cts:path-reference("//es:instance/Order/orderLines/OrderLine/total"),(0, 10, 100, 500, 1000, 5000, 10000))
let $min := data($bucket/cts:minimum)
let $max := data($bucket/cts:maximum)
return ($bucket, 
xdmp:sql('select * from "Order_orderlines" where total &gt;= @min and total &lt;= @max order by total', (),
  map:map()=&gt;map:with("min",$min)=&gt;map:with("max", $max)))</query><query active="true" focus="false" mode="xquery" name="10 ranges and sparql">xquery version "1.0-ml";
declare namespace es = "http://marklogic.com/entity-services";

let $r := cts:path-reference("//es:instance/Order/orderDate", "type=date")
for $orderDate in cts:values($r)
return

sem:sparql('
  select ?s ?p ?o 
  where { 
   ?s ?p ?o
  }
', (), (), cts:range-query($r, "=", $orderDate))
</query><query active="true" focus="false" mode="xquery" name="search and match">(: Here are several very simple operations with the venerable cts:* API :)

(: search all collections
cts:search(fn:collection(), "lorem");
 :)
 
(: search one collection
cts:search(fn:collection("envelopes"), "lorem")
 :)

(: a string in second argument is short form for a word query
cts:search(fn:collection("envelopes"), cts:word-query("ant", "stemmed"))
:)

(: cts:search(fn:collection("envelopes"), cts:word-query("ant")) :) 
 
(: construct a query  
cts:search(fn:collection("envelopes"), 
  cts:element-value-query(xs:QName("orderDate"), "2016-11-11"))
:)

declare namespace es = "http://marklogic.com/entity-services";

cts:search(fn:collection("envelopes"), 
  cts:range-query(cts:path-reference("//es:instance/Order/orderDate"), "&gt;=", xs:date("2016-11-11")))
  </query><query active="true" focus="false" mode="xquery" name="1 SQL">xdmp:sql("SELECT * from Product")
</query><query active="true" focus="false" mode="xquery" name="3 SPARQL">sem:sparql("PREFIX es: &lt;http://marklogic.com/entity-services#&gt;
select ?s ?o where { ?s a es:EntityType } limit 100")</query></workspace></export>